name: Release (signed assets)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Why are you running a dry-run? (for audit trail)'
        required: true
        type: string
      mode:
        description: 'Mode: dry-run (no upload) or upload-to-release (attach signed assets to an existing tag)'
        required: true
        type: choice
        options:
          - dry-run
          - upload-to-release
      tag:
        description: 'Required only for upload-to-release (e.g., v0.4.2)'
        required: false
        type: string

permissions:
  contents: read

jobs:
  dry-run:
    name: Dry-run (no upload)
    runs-on: ubuntu-latest
    permissions:
      contents: read
    if: github.event_name != 'release' && inputs.mode == 'dry-run'

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5
        with:
          python-version: '3.11'

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Resolve tag and verify version alignment
        env:
          TAG_NAME: ${{ inputs.tag }}
        run: |
          set -euo pipefail
          if [ -z "${TAG_NAME}" ]; then
            echo "inputs.tag is required for workflow_dispatch" >&2
            exit 1
          fi

          python - <<'PY'
          import os, re
          from pathlib import Path
          import tomllib
          tag = os.environ["TAG_NAME"]
          if not re.fullmatch(r"v\d+\.\d+\.\d+", tag):
              raise SystemExit(f"Invalid tag format: {tag!r} (expected vX.Y.Z)")
          pyproject = tomllib.loads(Path("pyproject.toml").read_text(encoding="utf-8"))
          version = pyproject.get("project", {}).get("version")
          expected = f"v{version}"
          if tag != expected:
              raise SystemExit(f"Tag/version mismatch: tag={tag!r} pyproject={version!r}")
          print(f"OK: tag={tag} version={version}")
          PY

      - name: Build package (sdist + wheel)
        run: python -m build

      - name: Generate checksums
        env:
          TAG_NAME: ${{ inputs.tag }}
        run: |
          set -euo pipefail
          GENERATED_UTC="$(date -u +"%Y-%m-%d %H:%M:%S UTC")"

          {
            echo "# SHA256 Checksums - schiavinato-sharing (Python)"
            echo ""
            echo "Version: ${TAG_NAME}"
            echo "Generated: ${GENERATED_UTC}"
            echo ""
            echo "## Dist files"
            echo ""
            (cd dist && sha256sum *)
            echo ""
            echo "## Verification"
            echo ""
            echo "sha256sum --check CHECKSUMS-PYPI.txt --ignore-missing"
          } > CHECKSUMS-PYPI.txt

          echo "=== Checksums Generated ==="
          cat CHECKSUMS-PYPI.txt

      - name: Ensure GPG secrets are configured
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ] || [ -z "${{ secrets.GPG_PASSPHRASE }}" ]; then
            echo "Missing GPG secrets. Configure GPG_PRIVATE_KEY and GPG_PASSPHRASE to produce signed release artifacts." >&2
            exit 1
          fi

      - name: Import GPG key
        run: |
          set -euo pipefail
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          gpg --list-secret-keys --keyid-format LONG

      - name: Sign artifacts (checksums + dist)
        run: |
          set -euo pipefail

          # Sign checksums
          echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes \
            --passphrase-fd 0 --pinentry-mode loopback \
            --armor --detach-sign CHECKSUMS-PYPI.txt
          gpg --verify CHECKSUMS-PYPI.txt.asc CHECKSUMS-PYPI.txt

          # Sign each dist file
          for f in dist/*; do
            echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes \
              --passphrase-fd 0 --pinentry-mode loopback \
              --armor --detach-sign "$f"
            gpg --verify "${f}.asc" "$f"
          done

          echo "✓ Signed and verified checksums + dist artifacts"

      - name: Upload artifacts (dry-run)
        uses: actions/upload-artifact@4c0ff1c489dca52fedb26375d7d8fe7bd9233f19 # v4.4.0
        with:
          name: release-dry-run-${{ inputs.tag }}
          path: |
            CHECKSUMS-PYPI.txt
            CHECKSUMS-PYPI.txt.asc
            dist/*
          retention-days: 14

  upload-to-release:
    name: Upload signed assets to GitHub Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    if: github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && inputs.mode == 'upload-to-release')

    steps:
      - name: Resolve tag
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "release" ]; then
            TAG_NAME="${{ github.event.release.tag_name }}"
          else
            TAG_NAME="${{ inputs.tag }}"
          fi
          if [ -z "${TAG_NAME}" ]; then
            echo "Missing tag (release tag_name or inputs.tag)." >&2
            exit 1
          fi
          echo "tag=${TAG_NAME}" >> "$GITHUB_OUTPUT"

      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5
        with:
          python-version: '3.11'

      - name: Verify tag/version alignment
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, re
          from pathlib import Path
          import tomllib
          tag = os.environ["TAG_NAME"]
          if not re.fullmatch(r"v\d+\.\d+\.\d+", tag):
              raise SystemExit(f"Invalid tag format: {tag!r} (expected vX.Y.Z)")
          pyproject = tomllib.loads(Path("pyproject.toml").read_text(encoding="utf-8"))
          version = pyproject.get("project", {}).get("version")
          expected = f"v{version}"
          if tag != expected:
              raise SystemExit(f"Tag/version mismatch: tag={tag!r} pyproject={version!r}")
          print(f"OK: tag={tag} version={version}")
          PY

      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Build package (sdist + wheel)
        run: python -m build

      - name: Generate checksums
        env:
          TAG_NAME: ${{ steps.meta.outputs.tag }}
        run: |
          set -euo pipefail
          GENERATED_UTC="$(date -u +"%Y-%m-%d %H:%M:%S UTC")"

          {
            echo "# SHA256 Checksums - schiavinato-sharing (Python)"
            echo ""
            echo "Version: ${TAG_NAME}"
            echo "Generated: ${GENERATED_UTC}"
            echo ""
            echo "## Dist files"
            echo ""
            (cd dist && sha256sum *)
            echo ""
            echo "## Verification"
            echo ""
            echo "sha256sum --check CHECKSUMS-PYPI.txt --ignore-missing"
          } > CHECKSUMS-PYPI.txt

      - name: Ensure GPG secrets are configured
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.GPG_PRIVATE_KEY }}" ] || [ -z "${{ secrets.GPG_PASSPHRASE }}" ]; then
            echo "Missing GPG secrets. Configure GPG_PRIVATE_KEY and GPG_PASSPHRASE to produce signed release artifacts." >&2
            exit 1
          fi

      - name: Import GPG key
        run: |
          set -euo pipefail
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          gpg --list-secret-keys --keyid-format LONG

      - name: Sign artifacts (checksums + dist)
        run: |
          set -euo pipefail

          # Sign checksums
          echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes \
            --passphrase-fd 0 --pinentry-mode loopback \
            --armor --detach-sign CHECKSUMS-PYPI.txt
          gpg --verify CHECKSUMS-PYPI.txt.asc CHECKSUMS-PYPI.txt

          # Sign each dist file
          for f in dist/*; do
            echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes \
              --passphrase-fd 0 --pinentry-mode loopback \
              --armor --detach-sign "$f"
            gpg --verify "${f}.asc" "$f"
          done

          echo "✓ Signed and verified checksums + dist artifacts"

      - name: Upload assets to GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: ${{ steps.meta.outputs.tag }}
        run: |
          set -euo pipefail
          gh release upload "${TAG_NAME}" \
            CHECKSUMS-PYPI.txt \
            CHECKSUMS-PYPI.txt.asc \
            dist/* \
            --clobber
